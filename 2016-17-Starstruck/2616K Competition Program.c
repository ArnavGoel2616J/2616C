#pragma config(Sensor, in1,    clawManiple,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  clawClose,      sensorTouch)
#pragma config(Sensor, dgtl2,  encoderI,       sensorQuadEncoder)
#pragma config(Motor,  port1,           leftrear,      tmotorVex393HighSpeed_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           liftLT,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           liftLB,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           leftfront,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           clawL,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           clawR,         tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port7,           rightfront,    tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           liftRT,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           liftRB,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          rightrear,     tmotorVex393HighSpeed_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#define FL motor[leftfront]
#define FR motor[rightfront]
#define BR motor[rightrear]
#define BL motor[leftrear]
#define liftLeft motor[liftLT] = motor[liftLB]
#define liftRight motor[liftRT] = motor[liftRB]
#define lift liftLeft = liftRight
#define claw motor[clawL] = motor[clawR]
bool vectordrive = true;
task Drive() {
    while(true) {
        switch(vectordrive) {
        case true:
            FL = (vexRT[Ch3] /* Y */ + vexRT[Ch4] /* X */) + vexRT[Ch1] /* R */;
            /* FL = -(y + x) - r */
            FR = (-vexRT[Ch3]/* Y */ + vexRT[Ch4] /* X */) + vexRT[Ch1] /* R */;
            /* FR = -(-y + x) - r */
            BR = (-vexRT[Ch3] /* Y */ - vexRT[Ch4] /* X */) + vexRT[Ch1] /* R */;
            /* BR = -(y + x) - r */
            BL = (vexRT[Ch3] /* Y */ - vexRT[Ch4] /* X */) + vexRT[Ch1] /* R */;
            /* BL = -(y - x) - r */
            if(vexRT[Btn8D]){
                vectordrive = false;
            }
            break;
        case false:
            FL = (vexRT[Ch2] /* Y */ + vexRT[Ch1] /* X */) + vexRT[Ch4] /* R */;
            /* FL = -(y + x) - r */
            FR = (-vexRT[Ch2]/* Y */ + vexRT[Ch1] /* X */) + vexRT[Ch4] /* R */;
            /* FR = -(-y + x) - r */
            BR = (-vexRT[Ch2] /* Y */ - vexRT[Ch1] /* X */) + vexRT[Ch4] /* R */;
            /* BR = -(y + x) - r */
            BL = (vexRT[Ch2] /* Y */ - vexRT[Ch1] /* X */) + vexRT[Ch4] /* R */;
            break;
        }
    }
}
task clawArm() {
    while(true){
        switch(vexRT[Btn6U]) {
        case 1:
        		lift = 127;
            while(vexRT[Btn6U]) {

            }
            break;
        case 0:
            lift = 0;
            break;
        }

        switch(vexRT[Btn6D]) {
        case 1:
            lift = -127;
            while(vexRT[Btn6D]) {

            }
            break;
        case 0:
        lift = 0;
            break;
        }
    }
}

task clawGrasp() {
    while(true) {
        switch(vexRT[Btn5U]) {
        case 1:
            claw = -127;
            while(vexRT[Btn5U]){

            }
        case 0:
            claw = 0;
        }

        switch(vexRT[Btn5D]) {
        case 1:
            claw = 127;
            while(vexRT[Btn5D]){

            }
            break;
        case 0:
            claw = 0;
            break;
        }
    }
}

void pre_auton() {
    bStopTasksBetweenModes = true;
    SensorValue[clawManiple] = 0;
}
void manipClaw(float angle) {
	while(SensorValue[clawManiple] < angle){

	}

}

task autonomous() {

}
task usercontrol() {
    startTask(Drive);
    startTask(clawArm);
    startTask(clawGrasp);
}
task pidControl() {
double K_p, K_i, K_d;

}
