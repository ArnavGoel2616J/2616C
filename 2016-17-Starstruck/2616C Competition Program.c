#pragma config(Sensor, in1,    clawManiple,    sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  odometricSensorY, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  odometricSensorX, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, ,               sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, ,               sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, ,               sensorLEDtoVCC)
#pragma config(Motor,  port1,           leftrear,      tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           liftLT,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           liftLB,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           leftfront,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           clawL,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           clawR,         tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port7,           rightfront,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           liftRT,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           liftRB,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          rightrear,     tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#define FL motor[leftfront]
#define FR motor[rightfront]
#define BR motor[rightrear]
#define BL motor[leftrear]
#define liftLeft motor[liftLT] = motor[liftLB]
#define liftRight motor[liftRT] = motor[liftRB]
#define lift liftLeft = liftRight
#define claw motor[clawL] = motor[clawR]
#define driveoff BR = BL = FL = FR = 0
#define wide 2350
#define closed 1200
#include "behaviours.c"
bool vectordrive = true;
task Drive() {
	while(true) {
		switch(vectordrive) {
		case true:

			drive1.Y1 = vexRT[Ch3];
			drive1.X1 = vexRT[Ch4];
			drive1.X2 = vexRT[Ch1];
			FR = -drive1.Y1 + drive1.X2 + drive1.X1;
			BR =  drive1.Y1 - drive1.X2 + drive1.X1;
			FL = drive1.Y1 + drive1.X2 + drive1.X1;
			BL =  -drive1.Y1 - drive1.X2 + drive1.X1;
			if(vexRT[Btn8D]){
				vectordrive = false;
			}
			break;
		case false:

			break;
		}
	}
}
task clawArm() {
	while(true){
		switch(vexRT[Btn6U]) {
		case 1:
			lift = -127;
			while(vexRT[Btn6U]) {

			}
			break;
		case 0:
			lift = 0;
			break;
		}

		switch(vexRT[Btn6D]) {
		case 1:
			lift = 127;
			while(vexRT[Btn6D]) {

			}
			break;
		case 0:
			lift = 0;
			break;
		}
	}
}
void pre_auton() {
	bStopTasksBetweenModes = true;
	// SensorValue[clawManiple] = 0;
}
task autonomous() {
	startTask(clawPos);
	claw1.tolerance = 120;
	claw1.speed = 90;
	claw1.desiredPos = 2350;
	wait1Msec(2000);
	drive1.Y1 = 127;
  FR = -drive1.Y1 + drive1.X2 + drive1.X1;
	BR =  drive1.Y1 - drive1.X2 + drive1.X1;
	FL = drive1.Y1 + drive1.X2 + drive1.X1;
	BL =  -drive1.Y1 - drive1.X2 + drive1.X1;
	lift = -63;
	while(SensorValue[liftPot] < 3500) {

	}
	lift = 0;
	driveoff;



}

task usercontrol() {
	/*startTask(spin);
	wait1Msec(5000);*/
	startTask(Drive);
	startTask(clawArm);
	//   startTask(clawGrasp);
	claw1.tolerance = 120;
	claw1.speed = 110;
	startTask(clawPos);
	startTask(macroSelection);
	startTask(incDecTolerance);
}
