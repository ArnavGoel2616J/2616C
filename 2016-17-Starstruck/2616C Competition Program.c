#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    clawManiple,    sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  clawClose,      sensorTouch)
#pragma config(Sensor, dgtl2,  x_quad,         sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  y_quad,         sensorQuadEncoder)
#pragma config(Motor,  port1,           leftrear,      tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           liftLT,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           liftLB,        tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           leftfront,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           clawL,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           clawR,         tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port7,           rightfront,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           liftRT,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           liftRB,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          rightrear,     tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#define FL motor[leftfront]
#define FR motor[rightfront]
#define BR motor[rightrear]
#define BL motor[leftrear]
#define liftLeft motor[liftLT] = motor[liftLB]
#define liftRight motor[liftRT] = motor[liftRB]
#define lift liftLeft = liftRight
#define claw motor[clawL] = motor[clawR]
#define driveoff BR = BL = FL = FR = 0
#define wide 2350
#define closed 1200
#define min 300
#define CoG 2300
#define max
#include "Gyro.c"
#include "OdometryMouse.c"
#include "clawBehaviors.c"
#include "driveBehaviors.c"
#include "liftBehaviors.c"
#include "behaviours.c"

// Includes and defines stop, executable code starts
BotLocation botLoc;
task Drive() {
	while(true) {
		switch(vectordrive) {
		case true:

			drive1.Y1 = vexRT[Ch3];
			drive1.X1 = vexRT[Ch4];
			drive1.X2 = vexRT[Ch1];
			FR = -drive1.Y1 + drive1.X2 + drive1.X1;
			BR =  drive1.Y1 - drive1.X2 + drive1.X1;
			FL = drive1.Y1 + drive1.X2 + drive1.X1;
			BL =  -drive1.Y1 - drive1.X2 + drive1.X1;
			if(vexRT[Btn8D]){
				vectordrive = false;
			}
			break;
		case false:

			break;
		}
	}
}
/*task clawArm() {
	while(true){
		switch(vexRT[Btn6U]) {
		case 1:
			lift = -127;
			while(vexRT[Btn6U]) {

			}
			break;
		case 0:
			lift = 0;
			break;
		}

		switch(vexRT[Btn6D]) {
		case 1:
			lift = 127;
			while(vexRT[Btn6D]) {

			}
			break;
		case 0:
			lift = 0;
			break;
		}
	}
}*/
void pre_auton() {
	bStopTasksBetweenModes = true;
	init_odometry(x_quad, y_quad);
}
task autonomous() {
	get_botlocation(botLoc);
	startTask(clawPos);
	claw1.tolerance = 120;
	claw1.speed = 90;
	claw1.desiredPos = 2350;
	wait1Msec(2000);
	drive1.Y1 = 127;
  FR = -drive1.Y1 + drive1.X2 + drive1.X1;
	BR =  drive1.Y1 - drive1.X2 + drive1.X1;
	FL = drive1.Y1 + drive1.X2 + drive1.X1;
	BL =  -drive1.Y1 - drive1.X2 + drive1.X1;
	lift = -63;
	while(SensorValue[liftPot] < 3500) {

	}
	lift = 0;
	driveoff;



}

task usercontrol() {
	/*startTask(spin);
	wait1Msec(5000);*/
	startTask(Drive);
	//   startTask(clawGrasp);
	claw1.tolerance = 120;
	claw1.speed = 110;
	lift1.tolerance = 400;
	lift1.speed = 40;
	startTask(clawPos);
	startTask(liftPos);
	startTask(macroSelection);
	startTask(incDecTolerance);
}
